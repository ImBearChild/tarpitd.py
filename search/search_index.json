{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tarpitd.py Slow your enemy down. tarpitd.py is a lightweight , single-file network tarpit tool that deliberately delays or disrupts client connections by sending slow or malformed responses. It implements a variety of response patterns that emulate common Internet services, intentionally disrupting client activities or even triggering crashes. This deceleration mechanism is particularly useful for deterring malicious or misbehaving clients , all while maintaining a low resource footprint. Start by reading the introductory tutorial , then check the Unix-style User Manual for more information. body.homepage>div.container>div.row>div.col-md-3 { display: none; } Getting Started User Guide Features Lightweight The tool is purposefully designed as a single, streamlined file, ensuring a quick and easy download. Not memory-intensive or CPU-intensive. Actually, it's \"sleep-intensive\". Multi-protocol Support tarpitd.py isn\u2019t limited to one communication standard: it is built with flexibility in mind. Whether the connection attempt uses SSH, HTTP, or even the robust standards of TLS, this tarpit is equipped to decelerating them all. Structured Logging With its integration of the Python standard library\u2019s logging module, tarpitd.py offers advanced logging capabilities. It captures detailed client connection data and outputs this information in a machine-friendly JSONL format Client Examination A standout feature of tarpitd.py is its ability to check client before sending response. It ensures that each client receives the appropriate reply, and enable the ability to trick NULL probe .","title":"Home"},{"location":"#tarpitdpy","text":"Slow your enemy down. tarpitd.py is a lightweight , single-file network tarpit tool that deliberately delays or disrupts client connections by sending slow or malformed responses. It implements a variety of response patterns that emulate common Internet services, intentionally disrupting client activities or even triggering crashes. This deceleration mechanism is particularly useful for deterring malicious or misbehaving clients , all while maintaining a low resource footprint. Start by reading the introductory tutorial , then check the Unix-style User Manual for more information. body.homepage>div.container>div.row>div.col-md-3 { display: none; } Getting Started User Guide","title":"tarpitd.py"},{"location":"about/","text":"About What Is a Tarpit? A tarpit, as defined by Wikipedia, is a service on a computer system (typically a server) designed to intentionally delay incoming connections. This concept is analogous to an actual tar pit in nature, where animals become stuck and slowly sink beneath the surface of a swamp. Similarly, an internet tarpit slows down client connections, impeding rapid or automated access. Why Use a Tarpit? A tarpit can be highly beneficial in scenarios involving hostile or automated clients. Here are some examples: Brute-force Attacks: A malicious SSH client may repeatedly attempt to log in via port 22 using weak passwords. A tarpit can slow these attempts, increasing the time cost of the attack. Automated Crawlers: Malicious web crawlers might try to gather sensitive information from your server. By deliberately slowing down their requests, a tarpit can hinder data collection and reduce the effectiveness of such attacks. By employing a tarpit, you effectively shift the resource burden, imposing higher costs on the attacker while protecting your server's legitimate operations. What Is a \"pattern\" in tarpitd.py? In the context of tarpitd.py, a \"pattern\" refers to a specific response behavior tailored to interact with different protocols and handle various types of client connections. For instance: HTTP Endless Header: To combat a malicious HTTP client, tarpitd.py might maintain a connection by slowly transmitting an endless HTTP header. This response keeps the client effectively trapped. ( http_endless_header ) HTML Bomb: Alternatively, tarpitd.py can be configured to send a malicious HTML payload that overloads the client's HTML parser, further exhausting its resources. ( http_deflate_html_bomb ) SSH Transport Hold: In order to fight against brute-force attackers, tarpitd.py will perform SSH handshake slowly, and send harmless message to keep connection open. ( ssh_trans_hold ) Since different response patterns yield different effects\u2014and clients may react in varied ways\u2014tarpitd.py supports multiple tarpit strategies even for a single protocol. How About Resource Consumption? An efficiently implemented tarpit is specifically designed to consume far fewer resources than a conventional server. Traditional server software processes client requests in full, including parsing requests and generating dynamic responses via CGI (e.g., Python or PHP). In contrast, tarpitd.py bypasses most of these steps, instead sending pre-generated content or even arbitrary bytes. To put it in perspective: A typical HTTP server like Apache or Caddy might require hundreds of megabytes\u2014or even gigabytes\u2014of memory depending on the workload. And it will consume much CPU time to prepare a response. In contrast, tarpitd.py may require as little as 12 MB of RAM to serve something as resource-intensive as an HTML bomb. With this bomb pre-generated, the only thing needs to do is sending the response. (Sadly, it's still larger than OpenSSHd. Python will take serval MBs, even for printing a \"hello world\") In many cases, a tarpit not only conserves resources on the defending side but also imposes greater computational and time costs on the attacker. For example, if the attacker attempts to parse the malicious HTML bomb, they may expend significantly more time and resources than the defender did to generate it. Likewise, if an attacker is solely interested in receiving HTTP headers, the defender\u2019s effort to generate a tarpit response may effectively waste the attacker\u2019s time. Is it secure? Almost yes. tarpitd.py will not read from client, except a few bytes to make sure the client is running corresponding protocol, so there is nothing to crack. tarpit.py checks client by default, because send an HTTP response to SSH client is pointless, and it helps when facing null probing. This feature can be turned off as desired. Why not use original endlessh? Because the author of endlessh said: Parting exercise for the reader: Using the examples above as a starting point, implement an SMTP tarpit using asyncio. Bonus points for using TLS connections and testing it against real spammers. So this is what I make for exercise.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#what-is-a-tarpit","text":"A tarpit, as defined by Wikipedia, is a service on a computer system (typically a server) designed to intentionally delay incoming connections. This concept is analogous to an actual tar pit in nature, where animals become stuck and slowly sink beneath the surface of a swamp. Similarly, an internet tarpit slows down client connections, impeding rapid or automated access.","title":"What Is a Tarpit?"},{"location":"about/#why-use-a-tarpit","text":"A tarpit can be highly beneficial in scenarios involving hostile or automated clients. Here are some examples: Brute-force Attacks: A malicious SSH client may repeatedly attempt to log in via port 22 using weak passwords. A tarpit can slow these attempts, increasing the time cost of the attack. Automated Crawlers: Malicious web crawlers might try to gather sensitive information from your server. By deliberately slowing down their requests, a tarpit can hinder data collection and reduce the effectiveness of such attacks. By employing a tarpit, you effectively shift the resource burden, imposing higher costs on the attacker while protecting your server's legitimate operations.","title":"Why Use a Tarpit?"},{"location":"about/#what-is-a-pattern-in-tarpitdpy","text":"In the context of tarpitd.py, a \"pattern\" refers to a specific response behavior tailored to interact with different protocols and handle various types of client connections. For instance: HTTP Endless Header: To combat a malicious HTTP client, tarpitd.py might maintain a connection by slowly transmitting an endless HTTP header. This response keeps the client effectively trapped. ( http_endless_header ) HTML Bomb: Alternatively, tarpitd.py can be configured to send a malicious HTML payload that overloads the client's HTML parser, further exhausting its resources. ( http_deflate_html_bomb ) SSH Transport Hold: In order to fight against brute-force attackers, tarpitd.py will perform SSH handshake slowly, and send harmless message to keep connection open. ( ssh_trans_hold ) Since different response patterns yield different effects\u2014and clients may react in varied ways\u2014tarpitd.py supports multiple tarpit strategies even for a single protocol.","title":"What Is a \"pattern\" in tarpitd.py?"},{"location":"about/#how-about-resource-consumption","text":"An efficiently implemented tarpit is specifically designed to consume far fewer resources than a conventional server. Traditional server software processes client requests in full, including parsing requests and generating dynamic responses via CGI (e.g., Python or PHP). In contrast, tarpitd.py bypasses most of these steps, instead sending pre-generated content or even arbitrary bytes. To put it in perspective: A typical HTTP server like Apache or Caddy might require hundreds of megabytes\u2014or even gigabytes\u2014of memory depending on the workload. And it will consume much CPU time to prepare a response. In contrast, tarpitd.py may require as little as 12 MB of RAM to serve something as resource-intensive as an HTML bomb. With this bomb pre-generated, the only thing needs to do is sending the response. (Sadly, it's still larger than OpenSSHd. Python will take serval MBs, even for printing a \"hello world\") In many cases, a tarpit not only conserves resources on the defending side but also imposes greater computational and time costs on the attacker. For example, if the attacker attempts to parse the malicious HTML bomb, they may expend significantly more time and resources than the defender did to generate it. Likewise, if an attacker is solely interested in receiving HTTP headers, the defender\u2019s effort to generate a tarpit response may effectively waste the attacker\u2019s time.","title":"How About Resource Consumption?"},{"location":"about/#is-it-secure","text":"Almost yes. tarpitd.py will not read from client, except a few bytes to make sure the client is running corresponding protocol, so there is nothing to crack. tarpit.py checks client by default, because send an HTTP response to SSH client is pointless, and it helps when facing null probing. This feature can be turned off as desired.","title":"Is it secure?"},{"location":"about/#why-not-use-original-endlessh","text":"Because the author of endlessh said: Parting exercise for the reader: Using the examples above as a starting point, implement an SMTP tarpit using asyncio. Bonus points for using TLS connections and testing it against real spammers. So this is what I make for exercise.","title":"Why not use original endlessh?"},{"location":"getting-started/","text":"Getting Started Installation Note: Tarpitd.py requires Python 3.11 or higher ! You don't have to run pip install or clone any repositories\u2014just download the tarpitd.py script and place it wherever you prefer. To use it as an executable, move the script to a directory listed in your $PATH (commonly /usr/local/bin or ~/.local/bin ) and mark it as executable: chmod +x tarpitd.py If you\u2019d rather install it via pip, you can do so with: python -m pip install git+https://github.com/ImBearChild/tarpitd.py.git@main First Few Tarpits Slowing Down SSH Brute-Force Attacks SSH ports are frequent targets for brute-force attacks. By converting the SSH port into a \u201ctrap,\u201d attackers connecting to the port receive endless banner messages or continuous ignore messages that force them to wait for a response. This significantly lengthens the time required for each attack attempt. Example: Run an SSH tarpit (in endlessh mode) on port 2222 of your machine: tarpitd.py -s endlessh:0.0.0.0:2222 This setup is effective for defending against SSH brute-force attacks by forcing attackers to spend much longer time on each connection, increasing the likelihood they will be detected and blocked. Thwarting Automated HTTP Scanning and Crawling Automated tools and crawlers are often used to scan for vulnerabilities and harvest content. For HTTP services, you can launch a tarpit pattern that an endless stream of HTTP headers. This forces scanning tools and crawlers to wait, drastically reducing their efficiency. For clients connecting via HTTPS/TLS, you can use one of tarpitd.py\u2019s TLS pattern \u2013 such as sending an endless sequence of HelloRequest messages. In this mode, connected TLS clients (for example, those using OpenSSL for testing or scanning) will eventually time out or declare handshake failures due to prolonged waiting. tarpitd.py allows you to launch multiple services in a single command, each using a different pattern, listening on different addresses and ports. Example 1: Run both an HTTP tarpit and an TLS tarpit concurrently: tarpitd.py -r -2 -s HTTP_ENDLESS_COOKIE:0.0.0.0:8088 -s tls_slow_hello:127.0.0.1:8443 In this case, the option -r -2 makes the program wait 2 seconds for every byte sent, forcing each malicious request to endure a long delay. Want to fight back harder? How about sending resource-intensive deflate-compressed data? This pattern will force client consume excessive resources, making them CPU-intensive and memory-intensive. Example 2: Consume client resources using a deflate-compressed HTML bomb: tarpitd.py -r 1024 -s HTTP_DEFLATE_HTML_BOMB:0.0.0.0:8088 Here, the tool sends a 1 MB compressed package that, when decompressed, may consume up to 1 GB of memory, with invalid HTML can confuse the client. With a rate limit of 1 KB/s, you can control the output flow while imposing heavy resource usage on the client. Configuration In a real-world scenario, you might need to defend against various types of attacks simultaneously. Instead of relying solely on command-line options, you can configure tarpitd.py with a dedicated configuration file. The TOML configuration file allows you to define multiple tarpit services with separate settings, such as different tarpit modes, rate limits, bind addresses, and client examination rules. This approach is particularly useful if you need to run several tarpit instances simultaneously, each with its own tailored behavior. Example: Combine examples up [tarpits] [tarpits.my_cool_ssh_tarpit] pattern = \"ssh_trans_hold\" client_examine = True max_clients = 128 rate_limit = -2 bind = [{ host = \"127.0.0.1\", port = \"2222\" }] [tarpits.http_tarpit] pattern = \"http_deflate_html_bomb\" rate_limit = 4096 bind = [ { host = \"127.0.0.1\", port = \"8080\" }, { host = \"127.0.0.1\", port = \"8000\" }, ] [tarpits.tls_tarpit] pattern = \"tls_endless_hello_request\" rate_limit = 1 bind = [ { host = \"127.0.0.1\", port = \"8443\" }, { host = \"127.0.0.1\", port = \"6697\" }, ] [client_trace] enable = true file = \"./client_trace.log\" stdout = false In this configuration: Each tarpit service (e.g., my_cool_ssh_tarpit, http_tarpit, tls_tarpit) is defined with its own settings. You can customize the bind addresses (host and port), rate limits, client examination, and maximum connection limits individually. The global [client_trace] section allows you to log connection details for future analysis. Save it to conf.toml . And run tarpitd.py with it. tarpitd.py -c ./conf.toml","title":"Guide"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"Note: Tarpitd.py requires Python 3.11 or higher ! You don't have to run pip install or clone any repositories\u2014just download the tarpitd.py script and place it wherever you prefer. To use it as an executable, move the script to a directory listed in your $PATH (commonly /usr/local/bin or ~/.local/bin ) and mark it as executable: chmod +x tarpitd.py If you\u2019d rather install it via pip, you can do so with: python -m pip install git+https://github.com/ImBearChild/tarpitd.py.git@main","title":"Installation"},{"location":"getting-started/#first-few-tarpits","text":"","title":"First Few Tarpits"},{"location":"getting-started/#slowing-down-ssh-brute-force-attacks","text":"SSH ports are frequent targets for brute-force attacks. By converting the SSH port into a \u201ctrap,\u201d attackers connecting to the port receive endless banner messages or continuous ignore messages that force them to wait for a response. This significantly lengthens the time required for each attack attempt. Example: Run an SSH tarpit (in endlessh mode) on port 2222 of your machine: tarpitd.py -s endlessh:0.0.0.0:2222 This setup is effective for defending against SSH brute-force attacks by forcing attackers to spend much longer time on each connection, increasing the likelihood they will be detected and blocked.","title":"Slowing Down SSH Brute-Force Attacks"},{"location":"getting-started/#thwarting-automated-http-scanning-and-crawling","text":"Automated tools and crawlers are often used to scan for vulnerabilities and harvest content. For HTTP services, you can launch a tarpit pattern that an endless stream of HTTP headers. This forces scanning tools and crawlers to wait, drastically reducing their efficiency. For clients connecting via HTTPS/TLS, you can use one of tarpitd.py\u2019s TLS pattern \u2013 such as sending an endless sequence of HelloRequest messages. In this mode, connected TLS clients (for example, those using OpenSSL for testing or scanning) will eventually time out or declare handshake failures due to prolonged waiting. tarpitd.py allows you to launch multiple services in a single command, each using a different pattern, listening on different addresses and ports. Example 1: Run both an HTTP tarpit and an TLS tarpit concurrently: tarpitd.py -r -2 -s HTTP_ENDLESS_COOKIE:0.0.0.0:8088 -s tls_slow_hello:127.0.0.1:8443 In this case, the option -r -2 makes the program wait 2 seconds for every byte sent, forcing each malicious request to endure a long delay. Want to fight back harder? How about sending resource-intensive deflate-compressed data? This pattern will force client consume excessive resources, making them CPU-intensive and memory-intensive. Example 2: Consume client resources using a deflate-compressed HTML bomb: tarpitd.py -r 1024 -s HTTP_DEFLATE_HTML_BOMB:0.0.0.0:8088 Here, the tool sends a 1 MB compressed package that, when decompressed, may consume up to 1 GB of memory, with invalid HTML can confuse the client. With a rate limit of 1 KB/s, you can control the output flow while imposing heavy resource usage on the client.","title":"Thwarting Automated HTTP Scanning and Crawling"},{"location":"getting-started/#configuration","text":"In a real-world scenario, you might need to defend against various types of attacks simultaneously. Instead of relying solely on command-line options, you can configure tarpitd.py with a dedicated configuration file. The TOML configuration file allows you to define multiple tarpit services with separate settings, such as different tarpit modes, rate limits, bind addresses, and client examination rules. This approach is particularly useful if you need to run several tarpit instances simultaneously, each with its own tailored behavior. Example: Combine examples up [tarpits] [tarpits.my_cool_ssh_tarpit] pattern = \"ssh_trans_hold\" client_examine = True max_clients = 128 rate_limit = -2 bind = [{ host = \"127.0.0.1\", port = \"2222\" }] [tarpits.http_tarpit] pattern = \"http_deflate_html_bomb\" rate_limit = 4096 bind = [ { host = \"127.0.0.1\", port = \"8080\" }, { host = \"127.0.0.1\", port = \"8000\" }, ] [tarpits.tls_tarpit] pattern = \"tls_endless_hello_request\" rate_limit = 1 bind = [ { host = \"127.0.0.1\", port = \"8443\" }, { host = \"127.0.0.1\", port = \"6697\" }, ] [client_trace] enable = true file = \"./client_trace.log\" stdout = false In this configuration: Each tarpit service (e.g., my_cool_ssh_tarpit, http_tarpit, tls_tarpit) is defined with its own settings. You can customize the bind addresses (host and port), rate limits, client examination, and maximum connection limits individually. The global [client_trace] section allows you to log connection details for future analysis. Save it to conf.toml . And run tarpitd.py with it. tarpitd.py -c ./conf.toml","title":"Configuration"},{"location":"manual/","text":"Manual Available manual pages include: tarpitd.py.1 : Program usage tarpitd.conf.5 : Configuration file format","title":"Index"},{"location":"manual/#manual","text":"Available manual pages include: tarpitd.py.1 : Program usage tarpitd.conf.5 : Configuration file format","title":"Manual"},{"location":"manual/tarpitd.conf.5/","text":"NAME tarpitd.conf - configuration file of tarpitd DESCRIPTION It is a TOML format file. [tarpits.<name>] Table <name> Name of this tarpit. For reference in log output. Has no effect on behavior. pattern= (str) Specifies the tarpit pattern. The name of the pattern is case-insensitive. For a complete list of supported patterns, see tarpit.py(1) . rate_limit= (int) Sets the data transfer rate limit. Follows the same rule as tarpit.py(1) . bind= (table) A list of addresses and ports to listen on. Every item in this list should contain host and port values; see the example below. max_clients= (int) The maximum number of clients the server will handle. This is calculated per bind port. client_examine (bool) Examine the client before sending a response. [client_trace] Table enable= (bool) Enable logging of client access. stdout= (bool) Output the client trace log to stdout (if client_trace is enabled). Note: Normal runtime logs are printed to stderr. This behavior is hard-coded. Please use a service manager or shell redirection if you want to save the log file. file= (str) Path to the client_trace log file. Example [tarpits] [tarpits.my_cool_ssh_tarpit] pattern = \"ssh_trans_hold\" client_examine = true max_clients = 128 rate_limit = -2 bind = [{ host = \"127.0.0.1\", port = \"2222\" }] [tarpits.http_tarpit] pattern = \"http_deflate_html_bomb\" rate_limit = 4096 bind = [ { host = \"127.0.0.1\", port = \"8080\" }, { host = \"::1\", port = \"8080\" }, { host = \"127.0.0.1\", port = \"8888\" }, ] [tarpits.tls_tarpit] pattern = \"tls_endless_hello_request\" rate_limit = 1 bind = [ { host = \"127.0.0.1\", port = \"8443\" }, { host = \"127.0.0.1\", port = \"6697\" }, ] [client_trace] enable = true file = \"./client_trace.log\" stdout = true AUTHOR Nianqing Yao [imbearchild at outlook.com] This program was made on the lands of the Aminoac people of the Amacinoas Nation. We pay our respects to their Elders, past and present. Sovereignty was never ceded.","title":"Tarpitd.conf.5"},{"location":"manual/tarpitd.conf.5/#name","text":"tarpitd.conf - configuration file of tarpitd","title":"NAME"},{"location":"manual/tarpitd.conf.5/#description","text":"It is a TOML format file.","title":"DESCRIPTION"},{"location":"manual/tarpitd.conf.5/#tarpitsname-table","text":"","title":"[tarpits.&lt;name&gt;] Table"},{"location":"manual/tarpitd.conf.5/#name_1","text":"Name of this tarpit. For reference in log output. Has no effect on behavior.","title":"&lt;name&gt;"},{"location":"manual/tarpitd.conf.5/#pattern-str","text":"Specifies the tarpit pattern. The name of the pattern is case-insensitive. For a complete list of supported patterns, see tarpit.py(1) .","title":"pattern= (str)"},{"location":"manual/tarpitd.conf.5/#rate_limit-int","text":"Sets the data transfer rate limit. Follows the same rule as tarpit.py(1) .","title":"rate_limit= (int)"},{"location":"manual/tarpitd.conf.5/#bind-table","text":"A list of addresses and ports to listen on. Every item in this list should contain host and port values; see the example below.","title":"bind= (table)"},{"location":"manual/tarpitd.conf.5/#max_clients-int","text":"The maximum number of clients the server will handle. This is calculated per bind port.","title":"max_clients= (int)"},{"location":"manual/tarpitd.conf.5/#client_examine-bool","text":"Examine the client before sending a response.","title":"client_examine (bool)"},{"location":"manual/tarpitd.conf.5/#client_trace-table","text":"","title":"[client_trace] Table"},{"location":"manual/tarpitd.conf.5/#enable-bool","text":"Enable logging of client access.","title":"enable= (bool)"},{"location":"manual/tarpitd.conf.5/#stdout-bool","text":"Output the client trace log to stdout (if client_trace is enabled). Note: Normal runtime logs are printed to stderr. This behavior is hard-coded. Please use a service manager or shell redirection if you want to save the log file.","title":"stdout= (bool)"},{"location":"manual/tarpitd.conf.5/#file-str","text":"Path to the client_trace log file.","title":"file= (str)"},{"location":"manual/tarpitd.conf.5/#example","text":"[tarpits] [tarpits.my_cool_ssh_tarpit] pattern = \"ssh_trans_hold\" client_examine = true max_clients = 128 rate_limit = -2 bind = [{ host = \"127.0.0.1\", port = \"2222\" }] [tarpits.http_tarpit] pattern = \"http_deflate_html_bomb\" rate_limit = 4096 bind = [ { host = \"127.0.0.1\", port = \"8080\" }, { host = \"::1\", port = \"8080\" }, { host = \"127.0.0.1\", port = \"8888\" }, ] [tarpits.tls_tarpit] pattern = \"tls_endless_hello_request\" rate_limit = 1 bind = [ { host = \"127.0.0.1\", port = \"8443\" }, { host = \"127.0.0.1\", port = \"6697\" }, ] [client_trace] enable = true file = \"./client_trace.log\" stdout = true","title":"Example"},{"location":"manual/tarpitd.conf.5/#author","text":"Nianqing Yao [imbearchild at outlook.com] This program was made on the lands of the Aminoac people of the Amacinoas Nation. We pay our respects to their Elders, past and present. Sovereignty was never ceded.","title":"AUTHOR"},{"location":"manual/tarpitd.py.1/","text":"NAME tarpitd.py - making a port into tarpit SYNOPSIS tarpitd.py [-h] [-r RATE] [-c [FILE]] [-s PATTERN:HOST:PORT [PATTERN:HOST:PORT ...]] [--manual] DESCRIPTION tarpitd.py listens on specified network ports and purposefully delays or troubles clients that connect to it. This tool can be used to tie up network connections by delivering slow or malformed responses, potentially keeping client connections open for extended periods. OPTIONS -c, --config FILE Load configuration from file. -s, --serve PATTERN:HOST:PORT [PATTERN:HOST:PORT ...] Start a tarpit pattern on the specified host and port. The name of PATTERN is case-insensitive. For a complete list of supported patterns, see the \u201cTARPIT PATTERN\u201d section below. -r RATE, --rate-limit RATE Set data transfer rate limit. A positive value limits the transfer speed to RATE bytes per second. A negative value causes the program to send one byte every |RATE| seconds (effectively 1/|RATE| bytes per second). -t, --trace-client [FILE] Log client access to FILE. The output is in jsonl format. Logs to stdout if FILE is left blank. -e, --examine-client [{check}] Examine the client before sending a response. The current implementation checks the first few bytes of the request to confirm that the client is using the corresponding protocol. --manual MANUAL Display the built-in manual page. By default, tarpitd.py will open tarpitd.py.1 . Available manual pages include: tarpitd.py.1 : Program usage tarpitd.conf.5 : Configuration file format TARPIT PATTERN HTTP http_endless_header Tested with: Firefox, Chromium, curl Sends an endless stream of HTTP header lines (specifically, Set-Cookie: ). Some clients will wait indefinitely for the header to end (or for a blank line indicating the end of the headers), while others (like curl) may have header size restrictions and close the connection once the limit is reached. http_bad_site Tested with: Firefox, Chromium Responds to the client with a small HTML page containing many links and a dead-loop script. Browsers that support JavaScript will get stuck, and those links may cause crawlers to repeatedly pull the webpage. http_deflate_html_bomb Tested with: Firefox, Chromium Sends a badly formed HTML document compressed using the deflate (zlib) algorithm. Most clients will consume significant CPU resources attempting to parse the malformed HTML. Note: The response is always compressed with deflate regardless of client support, as serving uncompressed output might waste bandwidth. When using curl, use the --compressed option to trigger decompression and ensure you have sufficient disk space to handle the decompressed content. http_deflate_size_bomb Tested with: Firefox, Chromium, curl Feeds the client a large amount of compressed zero data. The current implementation sends a compressed 1 MB file that decompresses to approximately 1 GB, with added invalid HTML to further confuse the client. Note: The deflate compression algorithm has its maximum compression rate limit at 1030.3:1. SSH endlessh Tested with: OpenSSH endlessh is a well-known SSH tarpit that traps SSH clients by sending endless banner messages. Although named \u201cendlessh\u201d, it does not implement the full SSH protocol; it simply emits continuous banner data. As a result, port scanners (such as nmap and censys) will not mark the port as running a true SSH service. ssh_trans_hold Tested with: OpenSSH This tarpit mimics an SSH server's initial handshake by sending valid SSH transport messages and key exchange information (per IETF RFC 4253). However, instead of completing the exchange, it repeatedly sends SSH_MSG_IGNORE messages. Although clients are supposed to ignore these messages according to the standard, the continual stream keeps the connection open indefinitely. Note: The implementation advertises itself as OpenSSH 8.9 on Ubuntu and replays a pre-recorded SSH key exchange. Future updates may alter aspects of this behavior. TLS tls_slow_hello Tested with: openssl (cli), gnutls (cli) Responds with a long (but still valid) server hello. Clients will read the complete message before the connection is closed. tls_endless_hello_request Tested with: openssl (cli), curl (with openssl) Sends an endless series of HelloRequest messages to the client. According to IETF RFC 5246 (the TLS 1.2 specification), clients should ignore extra HelloRequest messages during the negotiation phase, effectively keeping the connection open. This will affect all clients using OpenSSL, including curl. Firefox will report a timeout after 10 seconds. GNU TLS (and wget using it) will disconnect immediately, complaining about handshake failure. MISC egsh_aminoas Tested with: OpenSSH An alternative to endlessh, this service not only keeps connections open but also adds a cultural touch. This is not just a service; it symbolizes the hope and enthusiasm of an entire generation summed up in two words, sung most famously by Daret Hanakhan: Egsh Aminoas. When clients connect, they will randomly receive a quote from classical Aminoas culture, and tarpitd.py will log the same quote simultaneously. EXAMPLES Print this manual: tarpitd.py --manual Start an endlessh tarpit: tarpitd.py -s endlessh:0.0.0.0:2222 Start an endless HTTP tarpit with a 2-second per-byte delay: tarpitd.py -r-2 -s HTTP_ENDLESS_COOKIE:0.0.0.0:8088 Start an endless HTTP tarpit with a rate limit of 1 KB/s: tarpitd.py -r1024 -s HTTP_DEFLATE_HTML_BOMB:0.0.0.0:8088 Start two different HTTP tarpit services concurrently (the name of the pattern is case-insensitive): tarpitd.py -s http_deflate_html_bomb:127.0.0.1:8080 \\ HTTP_ENDLESS_COOKIE:0.0.0.0:8088 KNOWN ISSUE CONNECTION RESET Clients may face a connection reset when tarpitd.py sends a lot of data and then closes the connection before the client has received all of it. The root of this problem is not clear, as tarpitd.py will wait until all data is written to the socket before closing it. Therefore, if a client has not received all the data, tarpitd.py will not close the connection. \u201cA lot\u201d in this context means that only http_deflate_size_bomb with high or no rate limit, and set max_client to a relatively low value, will face this problem. However, since the use of a rate limit is highly recommended (and enabled by default), it should not affect our main use case. AUTHOR Nianqing Yao [imbearchild at outlook.com] This program was made on the lands of the Aminoac people of the Amacinoas Nation. We pay our respects to their Elders, past and present. Sovereignty was never ceded.","title":"Tarpitd.py.1"},{"location":"manual/tarpitd.py.1/#name","text":"tarpitd.py - making a port into tarpit","title":"NAME"},{"location":"manual/tarpitd.py.1/#synopsis","text":"tarpitd.py [-h] [-r RATE] [-c [FILE]] [-s PATTERN:HOST:PORT [PATTERN:HOST:PORT ...]] [--manual]","title":"SYNOPSIS"},{"location":"manual/tarpitd.py.1/#description","text":"tarpitd.py listens on specified network ports and purposefully delays or troubles clients that connect to it. This tool can be used to tie up network connections by delivering slow or malformed responses, potentially keeping client connections open for extended periods.","title":"DESCRIPTION"},{"location":"manual/tarpitd.py.1/#options","text":"","title":"OPTIONS"},{"location":"manual/tarpitd.py.1/#-c-config-file","text":"Load configuration from file.","title":"-c, --config FILE"},{"location":"manual/tarpitd.py.1/#-s-serve-patternhostport-patternhostport","text":"Start a tarpit pattern on the specified host and port. The name of PATTERN is case-insensitive. For a complete list of supported patterns, see the \u201cTARPIT PATTERN\u201d section below.","title":"-s, --serve PATTERN:HOST:PORT [PATTERN:HOST:PORT ...]"},{"location":"manual/tarpitd.py.1/#-r-rate-rate-limit-rate","text":"Set data transfer rate limit. A positive value limits the transfer speed to RATE bytes per second. A negative value causes the program to send one byte every |RATE| seconds (effectively 1/|RATE| bytes per second).","title":"-r RATE, --rate-limit RATE"},{"location":"manual/tarpitd.py.1/#-t-trace-client-file","text":"Log client access to FILE. The output is in jsonl format. Logs to stdout if FILE is left blank.","title":"-t, --trace-client [FILE]"},{"location":"manual/tarpitd.py.1/#-e-examine-client-check","text":"Examine the client before sending a response. The current implementation checks the first few bytes of the request to confirm that the client is using the corresponding protocol.","title":"-e, --examine-client [{check}]"},{"location":"manual/tarpitd.py.1/#-manual-manual","text":"Display the built-in manual page. By default, tarpitd.py will open tarpitd.py.1 . Available manual pages include: tarpitd.py.1 : Program usage tarpitd.conf.5 : Configuration file format","title":"--manual MANUAL"},{"location":"manual/tarpitd.py.1/#tarpit-pattern","text":"","title":"TARPIT PATTERN"},{"location":"manual/tarpitd.py.1/#http","text":"","title":"HTTP"},{"location":"manual/tarpitd.py.1/#http_endless_header","text":"Tested with: Firefox, Chromium, curl Sends an endless stream of HTTP header lines (specifically, Set-Cookie: ). Some clients will wait indefinitely for the header to end (or for a blank line indicating the end of the headers), while others (like curl) may have header size restrictions and close the connection once the limit is reached.","title":"http_endless_header"},{"location":"manual/tarpitd.py.1/#http_bad_site","text":"Tested with: Firefox, Chromium Responds to the client with a small HTML page containing many links and a dead-loop script. Browsers that support JavaScript will get stuck, and those links may cause crawlers to repeatedly pull the webpage.","title":"http_bad_site"},{"location":"manual/tarpitd.py.1/#http_deflate_html_bomb","text":"Tested with: Firefox, Chromium Sends a badly formed HTML document compressed using the deflate (zlib) algorithm. Most clients will consume significant CPU resources attempting to parse the malformed HTML. Note: The response is always compressed with deflate regardless of client support, as serving uncompressed output might waste bandwidth. When using curl, use the --compressed option to trigger decompression and ensure you have sufficient disk space to handle the decompressed content.","title":"http_deflate_html_bomb"},{"location":"manual/tarpitd.py.1/#http_deflate_size_bomb","text":"Tested with: Firefox, Chromium, curl Feeds the client a large amount of compressed zero data. The current implementation sends a compressed 1 MB file that decompresses to approximately 1 GB, with added invalid HTML to further confuse the client. Note: The deflate compression algorithm has its maximum compression rate limit at 1030.3:1.","title":"http_deflate_size_bomb"},{"location":"manual/tarpitd.py.1/#ssh","text":"","title":"SSH"},{"location":"manual/tarpitd.py.1/#endlessh","text":"Tested with: OpenSSH endlessh is a well-known SSH tarpit that traps SSH clients by sending endless banner messages. Although named \u201cendlessh\u201d, it does not implement the full SSH protocol; it simply emits continuous banner data. As a result, port scanners (such as nmap and censys) will not mark the port as running a true SSH service.","title":"endlessh"},{"location":"manual/tarpitd.py.1/#ssh_trans_hold","text":"Tested with: OpenSSH This tarpit mimics an SSH server's initial handshake by sending valid SSH transport messages and key exchange information (per IETF RFC 4253). However, instead of completing the exchange, it repeatedly sends SSH_MSG_IGNORE messages. Although clients are supposed to ignore these messages according to the standard, the continual stream keeps the connection open indefinitely. Note: The implementation advertises itself as OpenSSH 8.9 on Ubuntu and replays a pre-recorded SSH key exchange. Future updates may alter aspects of this behavior.","title":"ssh_trans_hold"},{"location":"manual/tarpitd.py.1/#tls","text":"","title":"TLS"},{"location":"manual/tarpitd.py.1/#tls_slow_hello","text":"Tested with: openssl (cli), gnutls (cli) Responds with a long (but still valid) server hello. Clients will read the complete message before the connection is closed.","title":"tls_slow_hello"},{"location":"manual/tarpitd.py.1/#tls_endless_hello_request","text":"Tested with: openssl (cli), curl (with openssl) Sends an endless series of HelloRequest messages to the client. According to IETF RFC 5246 (the TLS 1.2 specification), clients should ignore extra HelloRequest messages during the negotiation phase, effectively keeping the connection open. This will affect all clients using OpenSSL, including curl. Firefox will report a timeout after 10 seconds. GNU TLS (and wget using it) will disconnect immediately, complaining about handshake failure.","title":"tls_endless_hello_request"},{"location":"manual/tarpitd.py.1/#misc","text":"","title":"MISC"},{"location":"manual/tarpitd.py.1/#egsh_aminoas","text":"Tested with: OpenSSH An alternative to endlessh, this service not only keeps connections open but also adds a cultural touch. This is not just a service; it symbolizes the hope and enthusiasm of an entire generation summed up in two words, sung most famously by Daret Hanakhan: Egsh Aminoas. When clients connect, they will randomly receive a quote from classical Aminoas culture, and tarpitd.py will log the same quote simultaneously.","title":"egsh_aminoas"},{"location":"manual/tarpitd.py.1/#examples","text":"Print this manual: tarpitd.py --manual Start an endlessh tarpit: tarpitd.py -s endlessh:0.0.0.0:2222 Start an endless HTTP tarpit with a 2-second per-byte delay: tarpitd.py -r-2 -s HTTP_ENDLESS_COOKIE:0.0.0.0:8088 Start an endless HTTP tarpit with a rate limit of 1 KB/s: tarpitd.py -r1024 -s HTTP_DEFLATE_HTML_BOMB:0.0.0.0:8088 Start two different HTTP tarpit services concurrently (the name of the pattern is case-insensitive): tarpitd.py -s http_deflate_html_bomb:127.0.0.1:8080 \\ HTTP_ENDLESS_COOKIE:0.0.0.0:8088","title":"EXAMPLES"},{"location":"manual/tarpitd.py.1/#known-issue","text":"","title":"KNOWN ISSUE"},{"location":"manual/tarpitd.py.1/#connection-reset","text":"Clients may face a connection reset when tarpitd.py sends a lot of data and then closes the connection before the client has received all of it. The root of this problem is not clear, as tarpitd.py will wait until all data is written to the socket before closing it. Therefore, if a client has not received all the data, tarpitd.py will not close the connection. \u201cA lot\u201d in this context means that only http_deflate_size_bomb with high or no rate limit, and set max_client to a relatively low value, will face this problem. However, since the use of a rate limit is highly recommended (and enabled by default), it should not affect our main use case.","title":"CONNECTION RESET"},{"location":"manual/tarpitd.py.1/#author","text":"Nianqing Yao [imbearchild at outlook.com] This program was made on the lands of the Aminoac people of the Amacinoas Nation. We pay our respects to their Elders, past and present. Sovereignty was never ceded.","title":"AUTHOR"}]}